\documentclass[11pt,a4paper,english]{article}
\usepackage[english]{babel} % Using babel for norwegian hyphenation
\usepackage{lmodern} % Changing the font
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{tcolorbox}
\usepackage[parfill]{parskip} % Removes indents
\usepackage{amsmath} % Environment, symbols etc...
\usepackage{amssymb}
\usepackage{float} % Fixing figure locations
\usepackage{multirow} % For nice tables
\usepackage{graphicx} % For pictures etc...
\usepackage{enumitem} % Points/lists
\usepackage{url}
\usepackage{hyperref}

\definecolor{red}{RGB}{255,10,10}

% To include code(-snippets) with æøå
\usepackage{listings}
\lstset{
language=c++,
showspaces=false,
showstringspaces=false,
frame=l,
}

\tolerance = 5000 % Bedre tekst
\hbadness = \tolerance
\pretolerance = 2000

\numberwithin{equation}{section}

\newcommand{\conj}[1]{#1^*}
\newcommand{\ve}[1]{\mathbf{#1}} % Vektorer i bold
\let\oldhat\hat
\renewcommand{\hat}[1]{\mathbf{\oldhat{#1}}}
\newcommand{\trans}[1]{#1^\top}
\newcommand{\herm}[1]{#1^\dagger}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\bigO}[1]{\mathcal{O}\left( #1 \right)}

\newcommand{\spac}{\hspace{5mm}}

\title{UNIK4660 - Assignment 2}
\author{Wilhelm Karlsen and Magnus Eden}
\date{\today}

\begin{document}
\maketitle
In this assignment we are first to visualize two sets of vector fields by their field lines. Secondly, to create a Line Integral Convolution(LIC) implementation and show its functionality on these fields. The vector field are given in the form of two .hdf5 files and are two different hurricane simulations, Isabel and Metsim. 
\\
We are also to implement and compare different integration methods, specifically Forward Euler and Fourth Order Runge-Kutta, and use differently sized convolution kernels. The results are shown and discussed at the end of this report.

\section{Field Line Visualization}
Visualization of field lines are very dependent on the points, called seed points, from which the streamlines are calculated. Passing over the vector field and using everything for streamline will simply give a chaotic and unusable image. Seed point strategies are therefore employed to find the best start point for each streamline. 
\\
We have chosen to test evenly spaced seed points, as well as the "equal distance" seed point strategy.

\section{Line Integral Convolution}
LIC is a visualization technique used to show the motion and flow in fluids. Using a simple gray-scale noise image it generates a texture by taking every pixel in the image and running it through a convolution kernel. The intended effect is lines that follow the vector field, and gives good, intuitive understanding of the flow direction. The lines are kept distinct by the varying gray scales, though they can be given different colors to help show additional system information, such as the vector magnitude.

Given a field line $\sigma$, the operation can be described by
\begin{align*}
	I(x_0) = \int_{S_0+L}^{S_0-L}k(s - s_0)T(\sigma(s))ds
\end{align*}
Where $I(x_0)$ is the intensity of a pixel at $x_0 = \sigma(s_0)$. $k$ is the convolution kernel with length $2L$, and $s$ is the arc-length.

\subsection{Fast LIC}
Our LIC implementation uses the the "Fast LIC" algorithm presented in the lecture. With a constant box function as the filter kernel, the integration of the streamline origin is: \\
\begin{align*}
	I(x_0) = k \int^{n}_{i = -n}T(x_i)
\end{align*}
This allows the convolution of the streamline in both directions as we pass over the input image by the simple function below:
\begin{align*}
	I(x_{m+1}) &= I(x_m) + k[T(x_{m+1+n}) - T(x_{m-n})], m = 0, 1,..., M	\\
	I(x_{m-1}) &= I(x_m) + k[T(x_{m-1-n}) - T(x_{m+n})], m = 0, 1,..., M
\end{align*}
This should help speed up the execution. However, as we did not implement normal LIC, we do not have anything to compare it to.

\section{Implementation}
For our implementation, both for the Field Line Integration and LIC, we have chosen to use Simple DirectMedia Layer(SDL) library for the graphical representation. The library have allowed us to quickly see the effect of any changes we have done in the code.
\\
During the integration, handling of critical points is done by simply ignoring the point if it is used as the origin. Interpolation uses it as any other vector in the field.
Should the integration try to pass beyond the boundaries of the vector field, we stop the integration in that direction. In the LIC implementation this has the effect of cutting short the convolution in both directions.
\\
Using the 2L = 1/10 of resolution

\subsection{Forward Euler}
The forward Euler integration scheme is the simplest of the two schemes. 
\begin{align*}
	\psi_{n+1} =& \psi_n + hf(x_n, y_n)
\end{align*}
With $\psi_n$ as the current coordinates for the output image, $h$ as the step size and $f$ as the vector field function.

\subsection{Fourth Order Runge-Kutta}
Runge-Kutta is a bit more complicated, and where Euler takes the step in one go, RK divides it into four parts.
\begin{align*}
	k_1 =& f(x_n, y_n)h	\\
	k_2 =& f(x_n + \frac{k_1}{2}, y_n + \frac{k_1}{2})	\\
	k_3 =& f(x_n + \frac{k_2}{2}, y_n + \frac{k_2}{2})	\\
	k_4 =& f(x_n + k_3, y_n + k_3	\\	
	\psi_{n+1} =& \psi_n + \frac{k_1}{6} + \frac{k_2}{3} + \frac{k_3}{3} + \frac{k_4}{6}
\end{align*}


\section{Results}

Step size
streamline/filter-core length
Euler vs RungeKutta


\subsection{Forward Euler: FilterVariations}

%\includegraphics[scale=1.0]{PathFileName}

\subsection{4th order Runge-Kutta: FilterVariations}

%\includegraphics[scale=1.0]{PathFileName}

\section{Conclusion and Comparison}

\end{document}